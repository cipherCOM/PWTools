//
//  PWDispatchQueueGraph.mm
//  PWFoundation
//
//  Created by Kai Brüning on 1/09/15.
//
//

#import "PWDispatchQueueGraph.h"    // first for PWDISPATCH_USE_QUEUEGRAPH

#if PWDISPATCH_USE_QUEUEGRAPH

#import "PWDispatch.h"
#import "PWFoundationDebugOptionGroup.h"
#import "NSThread-PWExtensions.h"
#import <pthread/pthread.h>
// Suppress some warnings generated by the template code inside boost graph.
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wshadow"
#import <boost/unordered_map.hpp>
#import <boost/graph/graph_traits.hpp>
#import <boost/graph/adjacency_list.hpp>
#import <boost/graph/topological_sort.hpp>
#import <boost/graph/depth_first_search.hpp>
#import <boost/graph/breadth_first_search.hpp>
#import <boost/graph/visitors.hpp>
#import <boost/graph/exception.hpp>
#import <boost/graph/graph_utility.hpp>
#import <boost/function_output_iterator.hpp>
#pragma clang diagnostic pop

NS_ASSUME_NONNULL_BEGIN

DEBUG_OPTION_DEFINE_ENUM_D (PWDispatchQueueGraphStateOption, PWFoundationDebugGroup,
                            @"Dispatch Queue Graph", @"", DEBUG_OPTION_ENUM_AS_SUBMENU,
                            NSInteger, PWDispatchQueueGraphStateOff, DEBUG_OPTION_PERSISTENT,
                            @"Off", PWDispatchQueueGraphStateOff,
                            @"Minimal", PWDispatchQueueGraphStateMinimal,
                            @"With labels", PWDispatchQueueGraphStateWithLabels,
                            @"With stack bracktrace", PWDispatchQueueGraphStateWithBacktrace,
                            nil)

using namespace boost;

namespace PW {
    // Created via PWDispatchOnce before its first use.
    pthread_key_t gThreadLocalKey;
    
    struct VertexInfo {
        NSString* _Nullable label_;
        Class               class_;
    };
    struct EdgeInfo {
        NSArray<NSNumber*> *_Nullable  callStackReturnAddresses_;
    };

    typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::bidirectionalS, VertexInfo, EdgeInfo> GraphType;
    typedef GraphType::vertex_descriptor VertexDescriptor;
    typedef GraphType::edge_descriptor EdgeDescriptor;
    typedef boost::graph_traits<GraphType>::vertex_iterator GraphVertexIter;
    typedef boost::graph_traits<GraphType>::edge_iterator GraphEdgeIter;

    typedef boost::unordered_map<void*, VertexDescriptor> DispatchObjectToVertexMap;

    struct GraphImpl {
        GraphType                   g_;
        DispatchObjectToVertexMap   dispatchObjectToVertexMap_;

        inline VertexDescriptor vd (id<PWDispatchQueueing> dispatchQueue) const
        {
            return this->vd ((__bridge void*) dispatchQueue);
        }

        inline VertexDescriptor vd (void* dispatchQueueKey) const
        {
            DispatchObjectToVertexMap::const_iterator i = dispatchObjectToVertexMap_.find (dispatchQueueKey);
            return (i != dispatchObjectToVertexMap_.end()) ? i->second : GraphType::null_vertex();
        }

        inline VertexDescriptor ensureVD (void* dispatchQueueKey, Class objectClass, NSString* _Nullable label)
        {
            VertexDescriptor vd = this->vd (dispatchQueueKey);
            if (vd == GraphType::null_vertex()) {
                vd = add_vertex (g_);
                VertexInfo& vertexInfo = g_[vd];
                vertexInfo.label_ = [label copy];
                vertexInfo.class_ = objectClass;
                dispatchObjectToVertexMap_[dispatchQueueKey] = vd;
            }
            return vd;
        }
        
        void clear()
        {
            g_.clear();
            dispatchObjectToVertexMap_.clear();
        }
    };

    bool isIgnorableBackEdge (const GraphImpl& g, const EdgeDescriptor& backEdge);
    void findAndLogCycle (const GraphImpl& g, const EdgeDescriptor& backEdge);
    
    struct DAGTestVisitor: public dfs_visitor<>
    {
        DAGTestVisitor (const GraphImpl& g, EdgeDescriptor& backEdge)
            : g_ (g), backEdge_ (backEdge) {
        }
        
        void back_edge (const EdgeDescriptor& e, const GraphType& gt)
        {
            if (!isIgnorableBackEdge (g_, e)) {
                backEdge_ = e;
                throw not_a_dag();
            }
        }
        const GraphImpl&    g_;
        EdgeDescriptor&     backEdge_;
    };
    
    bool isDAG (const GraphImpl& g, bool logCycles)
    {
        bool isDAG = false;
        EdgeDescriptor backEdge;
        DAGTestVisitor dagTestVisitor (g, backEdge);
        
        // Note: throwing an exception is indeed BGL’s method to early-end a search.
        try {
            depth_first_search (g.g_, visitor (dagTestVisitor));
            isDAG = true;
        }
        catch (const not_a_dag& e) {
        }
        
        if (!isDAG && logCycles && PWDispatchQueueGraphStateOption > PWDispatchQueueGraphStateMinimal)
            findAndLogCycle (g, backEdge);
        
        return isDAG;
    }

    bool isIgnorableBackEdge (const GraphImpl& g, const EdgeDescriptor& backEdge)
    {
        // If a semaphore is signalled from the same queue which waits for it we either have a reproducible deadlock
        // or the signal is always before the wait and nothing bad happens. At least there is no concurency-based
        // variability in the result and therefore no need to flag this here.
        // The situation happens if some completion may sometimes be called synchronously before the API using the
        // handler returns and a semaphore is used to wait in case the handler is called later (and on a different
        // queue).
        
        // Ignore cycles created by a single semaphore and a single queue.
        VertexDescriptor v1 = source (backEdge, g.g_);
        VertexDescriptor v2 = target (backEdge, g.g_);
        // Follow all in-edges to the source of this edge and see whether their source is the target of this edge.
        auto edgeRange = in_edges (v1, g.g_);
        for (; edgeRange.first != edgeRange.second; ++edgeRange.first) {
            EdgeDescriptor ed = *edgeRange.first;
            if (source (ed, g.g_) == v2) {
                BOOL v1IsSemaphore = [g.g_[v1].class_ isSubclassOfClass:PWDispatchSemaphore.class];
                BOOL v2IsSemaphore = [g.g_[v2].class_ isSubclassOfClass:PWDispatchSemaphore.class];
                if (v1IsSemaphore != v2IsSemaphore)
                    return YES;
            }
            
        }
        return NO;
    }
    
    struct CycleVisitor: public dfs_visitor<>
    {
        CycleVisitor (std::vector<VertexDescriptor>& path)
            : path_ (path) {
        }
        
        void discover_vertex (const VertexDescriptor& v, const GraphType& g)
        {
            path_.push_back (v);
        }
        
        void finish_vertex (const VertexDescriptor& v, const GraphType& g)
        {
            path_.pop_back();
        }
        
        void back_edge (const EdgeDescriptor& e, const GraphType& g)
        {
            // Stop the search when the cycle was found.
            throw not_a_dag();
        }
        
        std::vector<VertexDescriptor>& path_;
    };

    void findAndLogCycle (const GraphImpl& g, const EdgeDescriptor& backEdge)
    {
        // Collect the smallest full cycle using a depth first search starting at the target vertex of the back edge.
        std::vector<VertexDescriptor> path;
        try {
            VertexDescriptor rootVertex = target (backEdge, g.g_);
            depth_first_search (g.g_, visitor (CycleVisitor (path)). root_vertex(rootVertex));
        }
        catch (const not_a_dag& e) {    // -> cycle is complete
        }
        
        // First log the complete cycle.
        PWLog (@"Synchronous dispatch cycle: ");
        for (auto iVertex : path) {
            const VertexInfo& vertexInfo = g.g_[iVertex];
            PWLog (@"%@ -> ", vertexInfo.label_);
        }
        const VertexInfo& vertexInfo = g.g_[path.front()];
        PWLog (@"%@\n", vertexInfo.label_);
        
        // If request, log the backtrace for each edge of the cycle.
        if (PWDispatchQueueGraphStateOption == PWDispatchQueueGraphStateWithBacktrace) {
            VertexDescriptor prevVertex = path.front();
            for (int i = 1; i <= path.size(); ++i) {
                int j = (i < path.size()) ? i : 0;
                VertexDescriptor nextVertex = path[j];
                
                PWLog (@"%@ -> %@:\n", g.g_[prevVertex].label_, g.g_[nextVertex].label_);
                PWLogPush();
                
                // Get the edge between these two vertices.
                auto edge_result = edge (prevVertex, nextVertex, g.g_);
                if (edge_result.second) {   // whether an edge was found
                    const EdgeInfo& edgeInfo = g.g_[edge_result.first];
                    PWLog (@"%@\n", [NSThread callStackSymbolsFromReturnAddresses:edgeInfo.callStackReturnAddresses_]);
                }
                else
                    // Since I can’t uses asserts here, I log out my astonishment.
                    // Note: did indeed happen, but likely do to missing removal of deallocated semaphores.
                    PWLog (@"Error: did not find corresponding edge in graph, very strange!");
                
                PWLogPop();
                
                prevVertex = nextVertex;
            }
        }
    }
};

using namespace PW;


@implementation PWDispatchQueueGraph
{
    // The private queue protects _graph data structure. Can’t use PWDispatch here because this would end in dead by
    // recursion.
    // IMPORTANT: must not use any Asserts while in this queue, because the use of PWDispatch in our assertion handling
    // would (and did) result in deadlock.
    dispatch_queue_t    _privateQueue;
    GraphImpl           _graph;
}

+ (void) load
{
    // Prime the active queue stack of the main thread with the main queue.
    // The Spotlight and Quicklook daemons somehow trigger a load on non-main threads.
    if (PWDispatchQueue.mainQueue.isCurrentDispatchQueue) {
        PWCurrentDispatchQueueElement* mainQueueElement
            = static_cast<PWCurrentDispatchQueueElement*> (malloc (sizeof (PWCurrentDispatchQueueElement)));
        [self pushCurrentDispatchQueueElement:mainQueueElement withDispatchQueue:PWDispatchQueue.mainQueue];
    }
}

+ (PWDispatchQueueGraph*) sharedGraph
{
    static PWDispatchQueueGraph* sharedGraph;
    PWDispatchOnce(^{
        sharedGraph = [[self alloc] init];
    });
    return sharedGraph;
}

+ (void) pushCurrentDispatchQueueElement:(PWCurrentDispatchQueueElement*)outNode
                       withDispatchQueue:(id<PWDispatchQueueing>)dispatchQueue
{
    NSParameterAssert (dispatchQueue);
    NSParameterAssert (outNode);

    PWDispatchOnce (^{
        int result = pthread_key_create (&gThreadLocalKey, NULL);
        NSAssert (result == 0, @"can’t create thread local key with errno %i", result);
    });

    outNode->nextElement_ = static_cast<PWCurrentDispatchQueueElement*> (pthread_getspecific (gThreadLocalKey));
    outNode->queue_ = dispatchQueue;
    int result = pthread_setspecific (gThreadLocalKey, outNode);
    NSAssert (result == 0, @"can’t set value under thread local key with errno %i", result);
}

+ (void) popCurrentDispatchQueueElement:(PWCurrentDispatchQueueElement*)inNode
{
    NSParameterAssert (inNode);
    
    int result = pthread_setspecific (gThreadLocalKey, inNode->nextElement_);
    NSAssert (result == 0, @"can’t set value under thread local key with errno %i", result);
}

+ (void) dumpCurrentDispatchQueues
{
    PWLog (@"Current dispatch queues with innermost first:\n");
    PWLogPush();
    for (PWCurrentDispatchQueueElement* iElement
            = static_cast<PWCurrentDispatchQueueElement*> (pthread_getspecific (gThreadLocalKey));
         iElement;
         iElement = iElement->nextElement_)
        PWLog (@"%@\n", iElement->queue_.dispatchQueueLabel);
    PWLogPop();
}

+ (nullable id<PWDispatchQueueing, PWDispatchQueueGraphLabeling>) innermostCurrentDispatchQueue
{
    PWCurrentDispatchQueueElement* topElement
        = static_cast<PWCurrentDispatchQueueElement*> (pthread_getspecific (gThreadLocalKey));
    return topElement ? (id<PWDispatchQueueing, PWDispatchQueueGraphLabeling>) topElement->queue_ : nil;
}

- (instancetype) init
{
    if ((self = [super init]) != nil) {
        _privateQueue = dispatch_queue_create ("PWDispatchQueueGraph", NULL);
        NSAssert (_privateQueue, @"bad");
    }
    return self;
}

- (void) removeDispatchObject:(id)dispatchObject
{
    if (PWDispatchQueueGraphStateOption == PWDispatchQueueGraphStateOff)
        return;

    NSParameterAssert (dispatchObject);
    void* dispatchObjectKey = (__bridge void*)dispatchObject;

    dispatch_sync (_privateQueue, ^{
        _graph.dispatchObjectToVertexMap_.erase (dispatchObjectKey);
    });
}

- (void) addSynchronousDispatchToQueue:(id<PWDispatchQueueGraphLabeling>)dispatchObject
{
    if (PWDispatchQueueGraphStateOption == PWDispatchQueueGraphStateOff)
        return;

    NSParameterAssert (dispatchObject);

    id<PWDispatchQueueGraphLabeling> sourceQueue = PWDispatchQueueGraph.innermostCurrentDispatchQueue;
    if (sourceQueue)
        [self addSynchronousDispatchFromQueue:sourceQueue toQueue:dispatchObject];
}

- (void) addSynchronousDispatchFromQueue:(id<PWDispatchQueueGraphLabeling>)sourceObject
                                 toQueue:(id<PWDispatchQueueGraphLabeling>)targetObject
{
    if (PWDispatchQueueGraphStateOption == PWDispatchQueueGraphStateOff)
        return;
    
    NSParameterAssert (sourceObject);
    NSParameterAssert (targetObject);
    NSParameterAssert (sourceObject != targetObject);
    
    void* sourceObjectKey = (__bridge void*)sourceObject;
    void* targetObjectKey = (__bridge void*)targetObject;
    
    NSString* sourceLabel;
    NSString* targetLabel;
    if (PWDispatchQueueGraphStateOption >= PWDispatchQueueGraphStateWithLabels) {
        sourceLabel = sourceObject.dispatchQueueLabel;
        targetLabel = targetObject.dispatchQueueLabel;
    }
    
    NSArray<NSNumber*>* callStackReturnAddresses;
    if (PWDispatchQueueGraphStateOption == PWDispatchQueueGraphStateWithBacktrace)
        callStackReturnAddresses = [NSThread.callStackReturnAddresses copy];
    
    dispatch_sync (_privateQueue, ^{
        VertexDescriptor sourceVD = _graph.ensureVD (sourceObjectKey, [sourceObject class], sourceLabel);
        VertexDescriptor targetVD = _graph.ensureVD (targetObjectKey, [targetObject class], targetLabel);
        auto add_result = add_edge (sourceVD, targetVD, _graph.g_);
        if (add_result.second && callStackReturnAddresses) {    // -> new edge
            EdgeInfo& edgeInfo = _graph.g_[add_result.first];
            edgeInfo.callStackReturnAddresses_ = callStackReturnAddresses;
        }
    });
}

- (void) dumpKnownDispatchQueues
{
    PWLog (@"Dispatch queues:\n");
    PWLogPush();
    for (auto vertexRange = vertices (_graph.g_); vertexRange.first != vertexRange.second; ++vertexRange.first) {
        PWLog (@"%@\n", _graph.g_[*vertexRange.first].label_);
    }
    PWLogPop();
}

- (BOOL) checkTreeStructure
{
    return [self checkTreeStructureAndLogCycles:YES];
}

- (BOOL) checkTreeStructureAndLogCycles:(BOOL)logCycles
{
    __block BOOL isValid;
    dispatch_sync (_privateQueue, ^{
        isValid = isDAG (_graph, logCycles);
    });
    return isValid;
}

- (void) reset
{
    NSAssert (PWDispatchQueue.mainQueue.isCurrentDispatchQueue, nil);
    PWCurrentDispatchQueueElement* topElement
        = static_cast<PWCurrentDispatchQueueElement*> (pthread_getspecific (gThreadLocalKey));
    NSAssert (topElement, nil);
    NSAssert (!topElement->nextElement_, nil);
    NSAssert (topElement->queue_ == PWDispatchQueue.mainQueue, nil);

    dispatch_sync (_privateQueue, ^{
        _graph.clear();
    });
}

@end

#pragma mark

@implementation PWDispatchSemaphore (PWDispatchQueueGraph)

- (nullable NSString*) dispatchQueueLabel
{
    return self.description;
}

@end

NS_ASSUME_NONNULL_END

#endif

